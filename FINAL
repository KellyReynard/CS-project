"""
Diese Applikation wurde im Rahmen des Kurses "Grundlagen und Methoden der Informatik f√ºr Wirtschaftswissenschaften" an der Universit√§t St. Gallen entwickelt.
Die Umsetzung erfolgte in Zusammenarbeit zwischen den Studierenden und ChatGPT, das als unterst√ºtzendes Werkzeug √ºber den gesamten Entwicklungsprozess hinweg eingesetzt wurde.

Der Einsatz von ChatGPT konzentrierte sich insbesondere auf folgende Aspekte:
-Unterst√ºtzung bei der Entwicklung von Codebausteinen und Funktionsvorschl√§gen auf Basis der definierten Anforderungen.
-Hilfe bei der Identifikation und Behebung von Programmfehlern.
-Anregungen zur Verbesserung der Code-Struktur, Lesbarkeit und Modularit√§t.
-Diskussion alternativer L√∂sungswege, Algorithmen und konzeptioneller Ans√§tze.
-Die Entwicklung erfolgte iterativ: Anforderungen und Ideen wurden formuliert, anschlie√üend gemeinsam mit ChatGPT reflektiert und diskutiert.
Vorschl√§ge der KI wurden kritisch gepr√ºft, mit dem eigenen Code verglichen und bei Eignung gezielt angepasst, verbessert, getestet und integriert.

Gem√§ss den Richtlinien der Universit√§t St. Gallen im Umgang mit generativer KI wird die Einbindung von ChatGPT hiermit transparent offengelegt. 
Die inhaltliche und technische Verantwortung f√ºr den finalen Code und die Applikation liegt bei uns Studierenden.
"""



import streamlit as st  # Streamlit ist das Framework f√ºr Web-Apps in Python
import requests         # Damit werden HTTP-Anfragen an APIs gesendet
import pandas as pd     # Die Library Pandas wird importiert f√ºr die Datenverarbeitung
import plotly.express as px  # Diese Bibliothek wird verwendet f√ºr interaktive Graphen
from streamlit_option_menu import option_menu  # Mit dieser Bibliothek kann ein Men√º in der Seitenleiste eingef√ºgt werden
import numpy as np      # Numpy hilft uns mit Zahlen und Arrays zu erstellen
from io import BytesIO # BytesIO erm√∂glicht uns das Arbeiten mit bin√§ren Daten
import yfinance as yf # mit Yahoo k√∂nnen Finanzdaten bezogen bzw. abgerufen werden
from sklearn.preprocessing import PolynomialFeatures # Dient zur Erzeugung von zus√§tzlichen Merkmalen f√ºr polynomielle Regressionen
from sklearn.linear_model import LinearRegression # wird importiert um lineare Regressionsanalysen durchzuf√ºhren
from streamlit_autorefresh import st_autorefresh # Wird importiert um die Seite "News" alle 60 Sekunden neu zu laden
from sklearn.model_selection import train_test_split # train_test_split hilft dabei, die Daten in Trainings- und Testdaten zu unterteilen
import matplotlib.pyplot as plt # matplotlib wird f√ºr die Visualisierung (Plotten) verwendet
from datetime import datetime, timedelta # datetime wird ben√∂tigt, um mit Datumswerten zu arbeiten
import openpyxl # openpyxl wird ben√∂tigt, um Excel-Dateien zu lesen
import feedparser # feedparser wird verwendet, um RSS-Feeds zu parsen

#Pers√∂nliche API-Schl√ºssel f√ºr den Zugang zu den Finanzdaten von den Datenanbieter
API_KEY_TWELVEDATA = "fa6409603f0f4d2d9413c1b0a01b68ed"
API_KEY_FMP = "g8o3R38ppGAobko7Iq3TFPCgQy6JjpyZ"
API_KEY_FINNHUB = "cvt9u2pr01qhup0v5oa0cvt9u2pr01qhup0v5oag"

st.set_page_config(page_title="The CapWise App", layout="wide")

with st.sidebar: #Erstellen des Navigationsmen√ºs in der linken Seitenleiste
    selected = option_menu(
        menu_title="Navigation",  #Titel des Men√ºs
        options=["√úbersicht", "Risikoprofil", "Investitionsempfehlung", "Obligationen Suche", "Aktien Suche", "News"],  # Men√ºoptionen
        icons=["house", "bar-chart", "lightbulb", "search", "graph-up", "newspaper"],  # Symbole neben den Optionen
        menu_icon="cast",  #Icon oben links
        default_index=0  #Die erste Seite ("Overview") wird standardm√§√üig angezeigt
    )
if selected == "√úbersicht": #Erste Seite: √úbersicht
    st.title("The CapWise App")
    st.write("Willkommen zur CapWise App! Die App hilft dir dabei dein Risikprofil zu bestimmen und dein Geld richtig anzulegen.")
    st.video("https://www.youtube.com/watch?v=K9SiRyumlzw") #Einf√ºgen unseres Videos in die Applikation


    st.markdown("""
    ### üí¨ Wer sind wir?

    Wir sind ein Team von Studierenden, das eine moderne, benutzerfreundliche Investment-App entwickelt hat.

    ---

    ### üéØ Unser Ziel

    Wir wollen es einfacher machen, in die Welt der Investitionen einzusteigen.  
    *Du gibst dein Risikoprofil an, wir geben dir klare Empfehlungen.*

    ---

    ### Was findest du in unserer App?

    - üìä *Risikoprofilanalyse* ‚Äì Wir analysieren deine Risikobereitschaft
    - üí° *Empfohlene Portfolio-Zusammensetzung* ‚Äì angepasst an deine individuelle Riskiobereitschaft
    - üîç *Obligationen√ºbersicht* ‚Äì mit Laufzeiten, Zinss√§tzen und Risiken
    - üìà *Aktienrecherche mit Prognose* ‚Äì inklusive Kursverlauf und Machine-Learning-Forecast
    - üì∞ *Live-Finanznachrichten* ‚Äì f√ºr jedes Unternehmen, z.B. Apple, IBM oder Tesla

    ---

    Diese Anwendung richtet sich an:
    - Einsteiger
    - Studierende
    - Finanzinteressierte

    """)

if selected == "Risikoprofil": #Zweite Seite: Hier werden Fragen aufgelistet, um das optimale Risikprofil zu ermitteln
    st.title("Risikoprofil")
    st.write("Hier wird dein Risikoprofil anhand einiger Fragen bestimmt.")
    age = st.slider("Wie alt bist du?", min_value=18, max_value=100, step=1)#Frage 1: Alter des Nutzers abfragen, extra erst ab dem Altersjahr von 18 Jahren m√∂glich
    invest_horizon = st.number_input("Wie viele Jahre m√∂chtest du anlegen?", min_value=1, step=1) #Frage 2: Anlagehorizont: Zahlenfeld, in dem die Anzahl Jahre der Investition bestimmt werden
    risk_behavior = st.slider("Wie risikofreudig bist du?", min_value=0, max_value=100, step=1, 
                              help="0 = konservativ, 100 = aggressiv")#Frage 3: Pers√∂nliche Risikobereitschaft (zwischen 0 und 100), wird bestimmt mit Slider
    st.write("Wie w√ºrdest du reagieren, wenn der Aktienkurs f√§llt?")   #Frage 4: Reaktion bei Kursverlusten, hier wird nachfolgend ein Graph aufgezeigt
    st.write("Beispiel: der Kurs sinkt um 20 %")

    #Visualisierung eines fallenden Aktienkurses, um dem Nutzer ein Gef√ºhl f√ºr Verluste zu geben, der aktualisiert sich jedesmal aufs neue
    dates = pd.date_range(start="2023-01-01", periods=100)
    start_price = 110
    end_price = start_price * 0.8  #20 % Verlust
    negativ_trend = np.linspace(start_price, end_price, 100)
    random_var = np.random.normal(loc=0, scale=2, size=100)
    stock_prices = negativ_trend + random_var #Preis mit Trend  Schwankungen berechnen
    df = pd.DataFrame({"Date": dates, "Price": stock_prices})
    df.set_index("Date", inplace=True)
    fig = px.line(df, x=df.index, y="Price", title="Fallender Aktienkurs")
    st.plotly_chart(fig)

    #hier dann die Frage 4, wie sich die Person f√ºhlt, bei so einem Kursr√ºckgang
    loss_feeling = st.radio("Wie f√ºhlst du dich bei finanziellen Verlusten?", 
                            options=["Kaum ber√ºhrt", "Waren mir unangenehm", "Unangenehm und Bef√ºrchtung alles zu verlieren", "Keine Aussage trifft zu"])

    #Frage 5: Wie viel Geld m√∂chte man investieren?
    invest_amount = st.selectbox("Wie hoch ist dein Anlagebetrag?", 
                                     options=["0-10 Tausend", "10-50 Tausend", "100-500 Tausend", ">500 Tausend"])

    #Klassifizierung des Nutzers in einen Anlagetyp, abh√§ngig von seinen Antworten, aber nur wenige Kombinationen. Es g√§be nat√ºrlich extrem viele verschieden Kombinationen, welche man kombinieren k√∂nnte um eine exaktes Anlageprofil zu bestimmen. Wir haben uns aus Komplexit√§tsgr√ºnden dagegen entschieden.
    if invest_horizon <= 5 and risk_behavior <= 30 and loss_feeling == "Unangenehm und Bef√ºrchtung alles zu verlieren" and invest_amount == "0-10 Tausend":
        asset_class = "Einkommen"
    elif invest_horizon <= 5 and risk_behavior <= 50 and loss_feeling in ["Unangenehm und Bef√ºrchtung alles zu verlieren", "Waren mir unangenehm"]:
        asset_class = "Defensiv"
    elif invest_horizon <= 10 and risk_behavior <= 50 and loss_feeling in ["Waren mir unangenehm", "Kaum ber√ºhrt"] and invest_amount in ["10-50 Tausend", "100-500 Tausend"]:
        asset_class = "Konservativ"
    elif invest_horizon >= 10 and risk_behavior <= 70 and loss_feeling in ["Kaum ber√ºhrt", "Waren mir unangenehm"]:
        asset_class = "Ausgewogen"
    elif invest_horizon >= 15 and risk_behavior >= 70 and loss_feeling == "Kaum ber√ºhrt" and invest_amount == ">500 Tausend":
        asset_class = "Aktien"    
    elif invest_horizon >= 10 and risk_behavior >= 60 and loss_feeling in ["Kaum ber√ºhrt", "Waren mir unangenehm"]:
        asset_class = "Wachstum"

    else:
        asset_class = "Ausgewogen"  #Standardtyp, wenn keine eindeutige Kategorie passt

    #Zeichnen der Risiko-Rendite-Kurve mit Markierung des entsprechenden Nutzerprofils
    x_risiko = np.linspace(0, 100, 6) #Risiko-Werte von 0 bis 100 f√ºr sechs Anlageklassen
    y_return = [1, 2.5, 4, 6.5, 9, 12] #Erwartete Renditen f√ºr die jeweiligen Risiko-Werte
    Asset_Klassen = ["Einkommen", "Defensiv", "Konservativ", "Ausgewogen", "Wachstum", "Aktien"]
    
    Verm√∂gens_Positionen = {x: (x_risiko[i], y_return[i]) for i, x in enumerate(Asset_Klassen)} #Mapping jeder Anlageklasse zu ihrer Risiko-Rendite-Koordinate

    #Erstellen einer Risiko-Rendite-Linie
    figure_risiko_return = px.line(x=x_risiko, y=y_return, labels={"x": "Risiko", "y": "Rendite"}, title="Risikoprofil und Anlagetypen")
    for item in Asset_Klassen: #Jede Anlageklasse wird als blauen Marker zur Grafik hinzugef√ºgt
        x_pos, y_pos = Verm√∂gens_Positionen[item]
        figure_risiko_return.add_scatter(x=[x_pos], y=[y_pos], mode="markers+text", text=[item], textposition="top center", marker=dict(size=8, color="blue"))

    selected_x, selected_y = Verm√∂gens_Positionen[asset_class] #Der vom Nutzer bestimmten Anlagetyp wird rot markiert
    figure_risiko_return.add_scatter(x=[selected_x], y=[selected_y], mode="markers+text", 
                                textposition="top center", marker=dict(size=12, color="red", line=dict(width=2, color="black")))

    st.plotly_chart(figure_risiko_return)
    
    st.write(f"**Basierend auf deinen Antworten ist dein Anlagetyp:** {asset_class}") #Anzeige des Namen des ermittelten Anlagetypen
    st.session_state["Anlagetyp"] = asset_class #Der Anlagetyp wird in Session State gespeichert und nachher verwendet im Tab Investitionsempfehlung
    
elif selected == "Investitionsempfehlung":  #Dritte Seite: Investitionsempfehlung basierend auf dem ermittelen Risikoprofil
    st.title("Investitionsempfehlung")
    st.write("Empfohlene Portfolio-Zusammensetzung basierend auf deinem Profil.")
    
    Asset_Klassen = ["Einkommen", "Defensiv", "Konservativ", "Ausgewogen", "Wachstum", "Aktien"]
    
   
    asset_class = st.session_state.get("Anlagetyp", "Unbekannt") #hier wird auf den vorherigen Risikotyp zugegriffen
    st.write(f"Die von dir bestimmte Anlageklasse: **{asset_class}**")
    
    #Nachfolgend sind die verschiedenen Kombinationen der Assetklassen je nach ermittelten Anlagetyp
    recommendations = {
        "Einkommen":   {"Aktien": 0.0,  "Obligationen": 0.9,  "Cash": 0.1},
        "Defensiv":    {"Aktien": 0.25, "Obligationen": 0.75, "Cash": 0.1},
        "Konservativ": {"Aktien": 0.35, "Obligationen": 0.55, "Cash": 0.1},
        "Ausgewogen":  {"Aktien": 0.55, "Obligationen": 0.35, "Cash": 0.1},
        "Wachstum":    {"Aktien": 0.75, "Obligationen": 0.15, "Cash": 0.1},
        "Aktien":      {"Aktien": 0.9,  "Obligationen": 0.0,  "Cash": 0.1}
    }

  
    if asset_class in recommendations: #falls der Anlagetyp g√ºltig ist wird ein Kuchendiagramm mit der Aufteilung auf die verschiedenen Anlageklassen dargestellt
        dist = recommendations[asset_class]
        df_dist = (
            pd.DataFrame.from_dict(dist, orient="index", columns=["Anteil"])
              .reset_index()
              .rename(columns={"index": "Assetklasse"})
        )
        fig_rec = px.pie(
            df_dist,
            names="Assetklasse",
            values="Anteil",
            title="Empfohlene Portfolio-Zusammensetzung"
        )
        st.plotly_chart(fig_rec)
    else:
        st.warning("Assetklasse wurde nicht gefunden in Investitionsempfehlung. Bitte √ºberpr√ºfe deinen Anlagetyp.") #Wurde von ChatGPT empfohlen, falls die Assetklasse nicht gefunden werden w√ºrde.

    st.info("Hinweis: Diese Empfehlung ist generisch und ersetzt keine individuelle Anlageberatung.") #Hinweis/Disclaimer, dass dies keine umfangreiche Bewertung des Analgetyps ist und somit keine Anlageempfehlung

elif selected == "Obligationen Suche":  #Vierte Seite: Obligationen anzeigen, eine Datenbank erstellt mittels Excel, aktuelle Obligationen Daten wurden von der Webpage von Six (https://www.six-group.com/de/market-data/bonds/bond-explorer.html) heruntergeladen und als Datenbank in das Projekt implementiert. 
    st.title("Obligationen Search")
    st.write("Aktuelle Obligationen auf dem Markt. Die Daten werden von SIX zur Verf√ºgung gestellt.")


    try:
    
        excel_url = "https://raw.githubusercontent.com/KellyReynard/CS-project/main/Anleihen_Daten.xlsx" #Zugrifft auf die Datenbank bzw. Excel
        response = requests.get(excel_url)
        response.raise_for_status() #hier wird ein Fehler aufgrufen, bei fehlerhaftem HTTP-Statuscode
        df_bonds = pd.read_excel(BytesIO(response.content), engine="openpyxl") #Excel Daten werden in einen DataFrame eingelesen
        if df_bonds["MaturityDate"].dtype in [int, float]: #hierbei wird das Datum der Maturity als Datum formatiert, da die Daten im Datentyp int/float vorliegen
            df_bonds["MaturityDate"] = pd.to_datetime(df_bonds["MaturityDate"].astype(int).astype(str), format="%Y%m%d")
        st.dataframe(df_bonds) #DF wird aufgerufen

    except Exception as e: #wieder von ChatGPT empfohlen, falls 
        st.error(f"Fehler beim Laden der Datei: {e}")

    
elif selected == "Aktien Suche":  #F√ºnfte Seite: Aktien suchen und Kursverlauf anzeigen
    st.title("Stock Search")

    session = requests.Session() #Session mit Header, ist f√ºr gewisse API's notwendig, um mehrere Anfragen an dieselbe API zu senden, d.h. dauerhafte Verbindung zur API
    session.headers.update({
    "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64)"}) #identifizierung von automatisierten Anfragen 

    ticker = st.text_input("Gib das Aktien-Ticker-Symbol ein (z.B. AAPL, IBM):") #Input Feld f√ºr die Ticker der Aktien
    selected_period = st.selectbox(
        "W√§hle den Zeitraum:",
        options=["1 Tag","7 Tage", "1 Monat", "3 Monate", "6 Monate", "1 Jahr", "2 Jahr", "5 Jahr", "10 Jahr"],
        index=1
    )

    period_to_outputsize = {
        "1 Tag": 1,
        "7 Tage": 7,
        "1 Monat": 30,
        "3 Monate": 90,
        "6 Monate": 180,
        "1 Jahr": 365,
        "2 Jahr": 730,
        "5 Jahr": 1825,
        "10 Jahr": 3650,
        
    } #Mapping des Zeitraums f√ºr die API Abfrage
    outputsize = period_to_outputsize[selected_period] #der vom Benutzer ausgew√§hlten Zeitraum wird in die numerische Anzahl Tage √ºbersetzt, wird verwendet f√ºr den Abruf der API

    if ticker:
        try:
            
            url_price = (
                f"https://api.twelvedata.com/time_series?"
                f"symbol={ticker}&interval=1day&outputsize={outputsize}&apikey={API_KEY_TWELVEDATA}" # Kursdaten werden der API TwelveData abgerufen
            )
            response_price = requests.get(url_price)
            data_price = response_price.json()

            if "values" in data_price: #DataFrame mit den Kursdaten wird erstellt, der DF wird nachher f√ºr den Plot verwendet
                df_price = pd.DataFrame(data_price["values"])
                df_price["datetime"] = pd.to_datetime(df_price["datetime"])
                df_price.set_index("datetime", inplace=True)
                df_price = df_price.astype(float)
                df_price.sort_index(inplace=True) 

                print(df_price.head())  #Debugging, Ausgabe der ersten Zeilen des DataFrames

                #Zeitreihen Plot wird erstellt, wobei der Aktienkurs dargestellt wird
                fig_price = px.line(
                    df_price,
                    x=df_price.index,
                    y="close",
                    title=f"{ticker} Aktienkurs √ºber {selected_period}"
                )
                st.plotly_chart(fig_price)
            else:
                st.error("Keine Daten f√ºr das eingegebene Ticker-Symbol gefunden.") #wurde von ChatGPT empfohlen, falls f√ºr den eingegeben Ticker keine Daten abgerufen werden k√∂nnen von der API

            #Abschnitt der Analystenempfehlungen, hier werden die Daten von der API Finnhub abegrufen, wobei die Anzahl von "Buy", "Hold" sowie "Sell" Einsch√§tzungen der Analysten angezeigt werden
            st.subheader("Analystenempfehlungen")
            url_finnhub = f"https://finnhub.io/api/v1/stock/recommendation?symbol={ticker}&token={API_KEY_FINNHUB}"
            response_finnhub = requests.get(url_finnhub)
            data_finnhub = response_finnhub.json()

            #Zeitlich sortierte Tabelle mit den Analystenbewertungen wird erstellt, danach wird von der die Einsch√§tzungen extrahiert
            if isinstance(data_finnhub, list) and len(data_finnhub) > 0: #Pr√ºft ob es eine Liste ist und diese nicht leer ist
                df_finnhub = pd.DataFrame(data_finnhub) 
                df_finnhub["period"] = pd.to_datetime(df_finnhub["period"]) #Bewertungdatum als String wird in eine Datumobjekt konvertiert
                df_finnhub = df_finnhub.sort_values("period", ascending=False) #Sortiert die Tabelle absteigend nach Datum, sodass die neueste Empfehlung oben steht

                #Anzeige der Analystenempfehlungen
                st.write("Die neuesten Empfehlungen respektive Analysteneinsch√§tzungen zu dieser Aktie")
                st.write(f"üü¢ Buy: {df_finnhub.iloc[0]['buy']}")
                st.write(f"üü° Hold: {df_finnhub.iloc[0]['hold']}")
                st.write(f"üî¥ Sell: {df_finnhub.iloc[0]['sell']}")

                
            else:
                st.info("Keine Analystendaten gefunden.") #wurde von ChatGPT empfohlen, falls keine Analystenempfehlugen f√ºr die eingegeben Aktien von der API abgerufen werden k√∂nnen



            # Der Titel der Web-App wird hier festgelegt
            st.title("Aktienkurs-Vorhersage mit Linearer Regression")
 
            
            #1) Pr√ºfen ob Daten vorhanden sind      
            if df_price.empty:
                st.error(f"Keine Daten f√ºr das Ticker-Symbol '{ticker}' gefunden. Bitte √ºberpr√ºfe den Ticker.")
            else:
                            #Daten werden abgerufen und gesamte Kurshistorie wird geladen
                start_date = "2015-01-01"
                end_date   = datetime.today().strftime("%Y-%m-%d")
                #hier wird eine URS zur TwelveData API eingebaut, um die Kursdaten im Tagesintervall zu laden
                url_price = (
                    f"https://api.twelvedata.com/time_series?"
                    f"symbol={ticker}&interval=1day"
                    f"&start_date={start_date}"
                    f"&end_date={end_date}"
                    f"&apikey={API_KEY_TWELVEDATA}"
                )
                resp = session.get(url_price)
                js  = resp.json()
                #Falls die Antwort keine Kurswerte enth√§lt, wird der Nutzer informiert und es wird gestoppt

                if "values" not in js:
                    st.error(f"No data for '{ticker}'.")
                    st.stop()

                df = pd.DataFrame(js["values"]) #JSON-Daten in einen DataFrame umwandeln.
                df["datetime"] = pd.to_datetime(df["datetime"]) #Die Spalte datetime wird in ein Datumsformat gebracht.
                df.set_index("datetime", inplace=True)
                df = df.astype(float).sort_index()  #Alle Werte werden als float konvertiert und chronologisch sortiert.


                #2)Regression vorbereiten
                df["Date"] = df.index #Erstellung einer neuen Spalte Date als Kopie des Index
                df["Date_ordinal"] = df["Date"].map(pd.Timestamp.toordinal) #Konvertierung jedes Datum in eine numerische Ganzzahl, was n√∂tig ist f√ºr das Regressionsmodell

                X = df[["Date_ordinal"]]
                y = df["close"]
                if len(df) < 2:
                    st.warning("Not enough points for regression.") #Wenn es zu wenige Datenpunkte gibt, wird die Regression nicht durchgef√ºhrt (wurde von ChatGPT empfohlen)
                    st.stop()
                #Train/Test Split mit Modelltraining, 80/20-Aufteilung der Daten f√ºr Training und Test    
                X_train, X_test, y_train, y_test = train_test_split(
                    X, y, test_size=0.2, shuffle=False
                )
                model = LinearRegression().fit(X_train, y_train)
                df["Prediction"] = model.predict(X)

                #3) Zuk√ºnftige Daten f√ºr zwei Jahre, beginnt ab de letzten Datum im Datensatz
                last = df["Date"].max()
                #Erstellen der zuk√ºnftige t√§gliche Datenpunkte ab dem n√§chsten Tag bis zwei Jahre sp√§ter
                future_dates = pd.date_range(
                    start=last + timedelta(days=1), #Start einen Tag nach dem letzten bekannten Datum
                    end= last + pd.DateOffset(years=2), #Ende ist genau zwei Jahre nach dem letzten bekannten Datum
                    freq="D" #T√§gliche zuk√ºnftige Datenpunkte f√ºr 2 Jahre
                )
                fut_ord = (
                    future_dates.map(pd.Timestamp.toordinal)
                                .to_numpy().reshape(-1,1) #hier werden die Datenpunkte in Ordinalzahlen umgewandelt, damit das Modell sie vorhersagen kann
                )
                future_preds = model.predict(fut_ord) #Verwendung des trainierten Modell, um die zuk√ºnftigen Kurse vorherzusagen

                #4) Die Vorhersage wird geplottet mit Matplotlib
                fig, ax = plt.subplots(figsize=(10,6))
                ax.plot(df["Date"], y, label="Echte Kurse")
                ax.plot(df["Date"], df["Prediction"],
                        linestyle="--",
                        label="In-sample Fit") #gestrichelte Linie zur Darstellung des Modell-Fits
                ax.plot(future_dates, future_preds,
                        linestyle="--",
                        label="Forecast (2 Jahre)") #gestrichelte Linie f√ºr den Prognosezeitraum
                ax.set_xlabel("Datum") #Achsenbeschriftung sowie Titel
                ax.set_ylabel("Kurs (USD)")
                ax.set_title(f"Vorhersage f√ºr {ticker} bis {future_dates[-1].date()}")
                ax.legend()
                st.pyplot(fig)
        except Exception as e:
            st.error(f"Fehler beim Abrufen der Daten: {e}") #Fehlerbehandlung, falls im gesamten Prozess etwas schiefl√§uft, wurde von ChatGPT empfohlen

                        
            

elif selected == "News":  #Sechste Seite: Aktuellste News zu jeweiligen Aktien anzeigen lasen

    try:
        st.title("B√∂rsennachrichten ‚Äì Echtzeit")
        st.caption("Die Seite aktualisiert sich automatisch alle 60 Sekunden.")  #Hinweis, dass sich die Seite jeweils automatisch aktualisiert

        #Automatische Aktualisierung der Seite alle 60 Sekunden, damit immer die aktuellsten News angezeigt werden
        st_autorefresh(interval=60 * 1000, key="news_refresh")

        #Eingabefeld, in das der Nutzer ein Ticker-Symbol eingibt
        symbol = st.text_input("Gib ein Ticker-Symbol ein (z.B. AAPL, TSLA, IBM):")

        #Holt Nachrichten √ºber yfinance f√ºr das eingegebene Symbol
        def get_yf_news(ticker_symbol):
            try:
                ticker = yf.Ticker(ticker_symbol)  #Objekt f√ºr das eingegebene Symbol wird erzeugt
                items = ticker.news or []  #Nachrichten abrufen (leere Liste, falls keine vorhanden)
                parsed = []  #Liste wird erstellt f√ºr die aufbereiteten Nachrichten

                for item in items:  #Iteration √ºber alle Nachrichten
                    if "title" in item and "provider" in item and "link" in item:
                        #Nur Nachrichten mit Titel, Quelle und Link verarbeiten
                        parsed.append({
                            "Titel": item["title"],
                            "Quelle": item["provider"].get("displayName", "Unbekannt"),
                            "Ver√∂ffentlicht am": item.get("providerPublishTime", 0),  #Zeit als Zeitstempel
                            "Link": item["link"]
                        })
                return parsed  #Hier wird die aufbereitete Nachrichtenliste zur√ºckgegeben

            except Exception as e:
                st.error(f"Fehler beim Abrufen der yfinance-Nachrichten: {e}")  #Fehlermeldung anzeigen, falls die News nicht abgerufen werden k√∂nne (von ChatGPT empfohlen)
                return []  #Leere Liste zur√ºckgeben, wenn Fehler auftritt

        #Holt Nachrichten √ºber Google News, falls yfinance leer ist. Zur Absicherung.
        def get_google_news(ticker_symbol):
            rss_url = (
                "https://news.google.com/rss/search?" # RL f√ºr die Google News-Suche (deutsche Ausgabe)
                f"q={ticker_symbol}%20Aktien&hl=de&gl=DE&ceid=DE:de"
            )

            feed = feedparser.parse(rss_url)  #RSS-Feed analysieren

            parsed = []

            for entry in feed.entries[:10]:  #Es werden nur die ersten 10 Eintr√§ge verwendet
                parsed.append({
                    "Titel": entry.title,
                    "Quelle": entry.get("source", {}).get("title", "Google News"),  #Quelle wird hier angegeben
                    "Ver√∂ffentlicht am": entry.get("published", ""),  #Ver√∂ffentlichungszeitpunkt
                    "Link": entry.link  #Direktlink zum Artikel
                })
            return parsed  #R√ºckgabe der aufbereiteten Nachrichten

        #Konvertiert und zeigt nachfolgend die Nachrichten sauber formatiert an
        def normalize_and_display(news_list):
            df = pd.DataFrame(news_list)  #Liste wird in ein DataFrame umgewandelt


            #Ver√∂ffentlichungszeitpunkt wird konvertiert, es werden zwei verschiedenen Methoden verwendet, um g√ºltige Datumsangaben zu erzeugen,
            #abh√§ngig davon, ob es sich um Unix-Zeitstempel oder Datumsstrings handelt.
            df["Ver√∂ffentlicht am"] = pd.to_datetime( #Die Spalte Ver√∂ffentlicht am wird in Datetime-Objekte umgewandelt, falls nicht klappt, wird im zweiten Versuch ung√ºltige Eintr√§ge koerciert, diesmal ohne unit="s"
                df["Ver√∂ffentlicht am"], 
                unit="s", errors="coerce"  #Wenn eine Umwandlung fehlschl√§gt, wird der Wert zu NaT, also ein ung√ºltiger Zeitwert
            ).fillna(pd.to_datetime(df["Ver√∂ffentlicht am"], errors="coerce")) #Jetzt wird angenommen, dass es sich um Datumsstrings handelt

            #Sortiere nach Ver√∂ffentlichungsdatum, neueste zuerst
            df.sort_values("Ver√∂ffentlicht am", ascending=False, inplace=True)

            df = df.head(10)

            #Hier werden aus den Links klickbare HTML-Links gemacht
            df["Link"] = df["Link"].apply(
                lambda url: f'<a href="{url}" target="_blank">√ñffnen</a>'
            )

            st.markdown("### Aktuelle Nachrichten:")


            #DataFrame als HTML-Tabelle anzeigen, HTML-Inhalte sind erlaubt (von ChatGPT empfohlen)
            st.write(df.to_html(escape=False, index=False), unsafe_allow_html=True) #Index-Spalte wird nicht ausgegebe, damit wir eine saubere Tabelle haben
            #"unsafe_allow_html" erlaubt es Links als klickbare Buttons darzustellen und erlaubt unischere HTML-Code

        #Wenn der Nutzer ein Ticker-Symbol eingegeben hat, werden die Nachrichten √ºber yfinance geholt
        if symbol:
            news = get_yf_news(symbol)

            if not news:  #Wenn jedoch keine yfinance-News vorhanden sind, wird als Backup Google News verwendet
                st.info(f"Keine yfinance-News f√ºr `{symbol}`‚Äîhole Google News RSS als Fallback.") #Dank RSS k√∂nnen die Inhalte maschinenlesbar bereitgestellt werden und die Inhalte automatisch aktualisiert werden
                news = get_google_news(symbol) 

            if news:
                normalize_and_display(news)
            else:
                st.info("Auch √ºber RSS keine Nachrichten verf√ºgbar.")  #Wenn sowohl √ºber yfinance und Google keine News abrufbar sind

        else:
            st.info("Bitte gib ein Ticker-Symbol ein, um Nachrichten zu sehen.")  #Hinweis, wenn hier kein Symbol eingegeben wurde

    except Exception as e:
        st.error(f"Fehler beim Laden der Nachrichten-Seite: {e}")  #Fehler allgemein abfangen und anzeigen, wurd ebenfalls von ChatGPT empfohlen, falls es nicht funktioniert
